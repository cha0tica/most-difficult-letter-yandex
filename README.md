# most-difficult-letter-yandex

<h1>Самая сложная буква - решение задачки из школы мобильной разработки Яндекс Практикум</h1>

Василий решил улучшить свою скорость печати. Он заметил, что некоторые буквы на клавиатуре он ищет дольше, чем другие. Ему интересно, какую букву он искал дольше всего. Напишите программу, которая поможет Василию узнать это.
Василий ввел N букв.
Строка S– строка, введенная Василием, имеет длину N
Mассив A содержит N целых неотрицательных чисел, каждое число Ai – время в миллисекундах от начала ввода до того как была напечатана i-тая буква.
Считается, что Василий начал искать следующую букву сразу после того, как напечатал предыдущую. Букву с индексом 0 он искал A0 миллисекунд.


<b>Формат ввода</b>
В первой строке входных данных находится 
N- количество введенных букв.

Во второй строке находится 
S– введенная строка, состоящая из N букв.

В третьей строке находится 
AN целых неотрицательных чисел через пробел.


<b>Пример</b>
3
abc
10 11 12
Вывод: а


<h2>Как решала:<h2>
<h3>Шаг 1. </h3>
Первое и самое важное, как оказалось, было разобраться с форматом ввода. Стандартные приемы codewars и leetcode, когда ты просто пишешь функцию и return в компиляторе яндекса не срабатывали. Нужно было осуществить либо чтение данных с консоли (readln), либо из файла. 
Я выбрала первый вариант и делала проект в файле для macOS с поддержкой command tool.

Количеством введенных букв (N) было простое число, поэтому для него не требовалось каких-то сложных решений:
<br><b>let n = Int(readLine()!)!</b>

Далее шла строка с символами (S). Ее нужно было передать в массив, так что этот кусочек кода был чуть сложнее:
<br><b>let s = readLine()!.compactMap { Character(extendedGraphemeClusterLiteral: $0) }</b>

Третью строчку также превращаем в массив. Но, поскольку она не склеена, как предыдущая, разбиваем ее не посимвольно, а ориентируясь на разделитесь в виде пробела (в коде он называется (separator: " «))
<br><b>let a = readLine()!.split(separator: " ").map(String.init).compactMap { Int($0) }</b>

Отлично, данные получены


<h3>Шаг 2. </h3>
Создаем две переменные. В первой будем записывать количество секунд, во второй - символ. Количество секунд изначально будет 0, так как счет потраченного времени начинается с нуля и до первой цифры, которую мы получили в строке A.
<b>var maxKey = a[0]
var maxChar = s[0]</b>

<h3>Шаг 3. </h3>
Кодим
Выполняем цикл for in столько раз, сколько у нас есть букв (ориентируемся по строке N)
Если результат от вычитания текущего числа секунд из предыдущего больше или равен количеству секунд, которые мы записали в maxKey, то пишем в maxKey разницу между этими секундами, а в с maxChar - текущую букву.

<b>for i in 1..<n {
    if (a[i] - a[i - 1]) >= maxKey {
        maxKey = a[i] - a[i - 1]
        maxChar = s[i]
    }
}</b>

Возьмем пример
3
abc
10 11 12

Повторяем три раза.
В первый раз: 10 - 0 = 10 - столько секунд понадобилось Василию, чтобы найти букву a. 10 > 0, который записан в maxKey. Следовательно, пока что это самое большое число. Записываем его в maxKey, а букву А в maxChar. 
Во второй раз: 11 - 10 = 1 - за столько была найдена b. Сравниваем с maxChar - 1 меньше 10. Ничего никуда не записываем.
В третий раз: 12 - 11 = 1 - ситуация повторяется. Ничего никуда не записываем.

Итого: правильный ответ - буква «a». На ее поиски ушло 10 секунд.
